<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <pre>
        <h1>1. Global, Local, and Nonlocal Variables</h1>
x = "global"
def outer():
    x = "outer local"

    def inner():
        nonlocal x
        x = "inner nonlocal"
        print("Inner:", x)

    inner()
    print("Outer:", x)

print("Global:", x)
outer()
print("Global after calling outer:", x)
    </pre>
    <pre>
        <h1>2. Positional, Keyword, Default, and Variable-length Arguments</h1>
def demonstrate_args(a, b, c=10, *args, **kwargs):
    print("Positional:", a, b)
    print("Default:", c)
    print("Variable-length args:", args)
    print("Keyword args:", kwargs)

demonstrate_args(1, 2, 3, 4, 5, x=100, y=200)
    </pre>
    <pre>
        <h1>3. Function Argument Unpacking (*args and **kwargs)</h1>
def unpacking_example(*args, **kwargs):
    print("args:", args)
    print("kwargs:", kwargs)

unpacking_example(1, 2, 3, a=4, b=5)
    </pre>
    <pre>
        4. Power of Two Numbers Using Function
def power(x, y):
    return x ** y

print("Power:", power(2, 3))
    </pre>
    <pre>
        <h1>5. Factorial Using Recursive Function</h1>
def factorial(n):
    if n == 0:
        return 1
    return n * factorial(n - 1)

print("Factorial:", factorial(5))
    </pre>
    <pre>
        <h1>6. Biggest Number Between Three Numbers</h1>
def biggest(a, b, c):
    return max(a, b, c)

print("Biggest:", biggest(1, 2, 3))
    </pre>
    <pre>
        <h1>7. Smallest Number Between Three Numbers</h1>
def smallest(a, b, c):
    return min(a, b, c)

print("Smallest:", smallest(1, 2, 3))
    </pre>
    <pre>
    <h1>8. Armstrong Number Check</h1>
def is_armstrong(number):
    num_str = str(number)
    power = len(num_str)
    return number == sum(int(digit) ** power for digit in num_str)

print("Is Armstrong:", is_armstrong(153))
    </pre>
    <pre>
<h1>9. Area and Circumference of Circle</h1>
import math

def circle_metrics(radius):
    area = math.pi * radius ** 2
    circumference = 2 * math.pi * radius
    return area, circumference

print("Circle Metrics:", circle_metrics(5))
    </pre>
    <pre>
        <h1>10. Sine Series</h1>
import math

def func(x, n):
    r = 0
    s = -1
    # Convert degrees to radians using the precise value of pi
    x = x * (math.pi / 180)
    for y in range(n):
        k = (2 * y) + 1
        s *= -1
        g = (x ** k) / math.factorial(k)
        r += (s * g)
    return r

# Test with an angle of 90 degrees and 5 terms
print(func(90, 5))
    </pre>
    <pre>
        <h1>11. Arithmetic Calculation Using Match Case</h1>
def arithmetic(a, b, operation):
    match operation:
        case 'add':
            return a + b
        case 'subtract':
            return a - b
        case 'multiply':
            return a * b
        case 'divide':
            return a / b

print("Result:", arithmetic(10, 5, 'add'))
    </pre>
    <pre>
        <h1>12. Fibonacci Series</h1>
def fibonacci(n):
    a, b = 0, 1
    for _ in range(n):
        print(a, end=" ")
        a, b = b, a + b

fibonacci(10)
    </pre>
    <pre>
        <h1>13. Multiplication Table</h1>
def multiplication_table(n):
    for i in range(1, 11):
        print(f"{n} x {i} = {n * i}")

multiplication_table(5)

<h1>14. Custom Assertions</h1>

def custom_assertions(x):
    assert x > 0, "x must be positive"
    assert isinstance(x, int), "x must be an integer"

try:
    custom_assertions(-1)
except AssertionError as e:
    print(e)
<h1>15. Recursive vs Iterative Factorial (Performance Comparison)</h1>
import time

def factorial_recursive(n):
    if n == 0:
        return 1
    return n * factorial_recursive(n - 1)

def factorial_iterative(n):
    result = 1
    for i in range(1, n + 1):
        result *= i
    return result

n = 1000

start = time.time()
factorial_recursive(n)
print("Recursive Time:", time.time() - start)

start = time.time()
factorial_iterative(n)
print("Iterative Time:", time.time() - start)
<h1>16. Class Hierarchy Demonstration</h1>
class Animal:
    def speak(self):
        return "Animal sound"

class Dog(Animal):
    def speak(self):
        return "Bark"

dog = Dog()
print(dog.speak())
<h1>17. Polymorphism with Base and Derived Classes</h1>
class Shape:
    def area(self):
        pass

class Circle(Shape):
    def area(self, radius):
        return 3.14 * radius ** 2

shape = Circle()
print("Area of Circle:", shape.area(5))
<h1>18. Attribute Access vs Getters/Setters</h1>
import time

class Example:
    def __init__(self, value):
        self._value = value

    @property
    def value(self):
        return self._value

    @value.setter
    def value(self, value):
        self._value = value

ex = Example(10)

start = time.time()
for _ in range(1000000):
    ex.value = 20
print("Property Time:", time.time() - start)

start = time.time()
for _ in range(1000000):
    ex._value = 20
print("Direct Time:", time.time() - start)
<h1>19. Custom Collection Class vs Built-in Data Structures</h1>
from collections import deque
import time

class Stack:
    def __init__(self):
        self.items = []

    def push(self, item):
        self.items.append(item)

    def pop(self):
        return self.items.pop()

stack = Stack()
deque_stack = deque()

start = time.time()
for i in range(100000):
    stack.push(i)
print("Custom Stack Push Time:", time.time() - start)

start = time.time()
for i in range(100000):
    deque_stack.append(i)
print("Deque Stack Push Time:", time.time() - start)
<h1>20. Function Decorators (Execution Time and Memory Usage)</h1>
import time

def decorator(func):
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        print("Execution Time:", time.time() - start)
        return result
    return wrapper

@decorator
def sample_function():
    time.sleep(1)

sample_function()

# Without Decorator
start = time.time()
time.sleep(1)
print("Execution Time (without decorator):", time.time() - start)
<h1>21. Single Inheritance</h1>
class Parent:
    def speak(self):
        print("Parent speaking")

class Child(Parent):
    pass

child = Child()
child.speak()
<h1>22. Multiple Inheritance</h1>
class Mother:
    def speak(self):
        print("Mother speaking")

class Father:
    def speak(self):
        print("Father speaking")

class Child(Mother, Father):
    pass

child = Child()
child.speak()
<h1>23. Multilevel Inheritance</h1>
class Grandparent:
    def speak(self):
        print("Grandparent speaking")

class Parent(Grandparent):
    pass

class Child(Parent):
    pass

child = Child()
child.speak()
<h1>24. Binary vs Text File Handling (Efficiency Comparison)</h1>
import time

# Binary file handling
start = time.time()
with open('binary_file.bin', 'wb') as file:
    for i in range(1000000):
        file.write(i.to_bytes(4, 'big'))
print("Binary Write Time:", time.time() - start)

# Text file handling
start = time.time()
with open('text_file.txt', 'w') as file:
    for i in range(1000000):
        file.write(str(i) + '\n')
print("Text Write Time:", time.time() - start)
<h1>25. Basic Django Web Application</h1>
<b>views</b>
from django.http import HttpResponse

def home(request):
    return HttpResponse("Hello, this is a basic Django web app!")
<b>urls</b>
from django.urls import path
from . import views

urlpatterns = [
    path('', views.home, name='home'),
]
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('', include('myapp.urls')),
]

</pre>

</body>
</html>